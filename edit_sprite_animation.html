<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite & Tile Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            min-height: 100vh;
            padding: 20px;
            gap: 30px;
        }
        
        .container {
            display: flex;
            gap: 30px;
            width: 100%;
        }
        
        .editor-section {
            flex: 1;
        }
        
        .sidebar {
            width: 320px;
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border: 1px solid #444;
        }
        
        h1, h2, h3 {
            color: #fff;
            margin-bottom: 15px;
        }
        
        h1 {
            font-size: 24px;
            border-bottom: 2px solid #4a9eff;
            padding-bottom: 10px;
        }
        
        h2 {
            font-size: 18px;
            color: #4a9eff;
        }
        
        h3 {
            font-size: 16px;
            color: #ccc;
        }
        
        canvas {
            border: 2px solid #444;
            border-radius: 8px;
            background: #222;
            cursor: crosshair;
            display: block;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            margin: 4px 0;
        }
        
        button:hover {
            background: #5aa8ff;
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.secondary {
            background: #666;
        }
        
        button.secondary:hover {
            background: #777;
        }
        
        button.danger {
            background: #e74c3c;
        }
        
        button.danger:hover {
            background: #ff6b5b;
        }
        
        button.success {
            background: #2ecc71;
        }
        
        button.success:hover {
            background: #3edd82;
        }
        
        .section {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 8px;
            margin: 15px 0;
        }
        
        .color-swatch {
            width: 30px;
            height: 30px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
        }
        
        .color-swatch.selected {
            border-color: white;
            box-shadow: 0 0 0 2px #4a9eff;
        }
        
        .color-swatch .color-index {
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.8);
            padding: 2px;
        }
        
        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }
        
        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #2a2a2a;
            color: white;
            margin-bottom: 10px;
        }
        
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #2a2a2a;
            color: white;
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #bbb;
        }
        
        .frame-thumbnails {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
            max-height: 120px;
            overflow-y: auto;
            padding: 5px;
        }
        
        .frame-thumb {
            width: 40px;
            height: 40px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            background: #222;
            position: relative;
            overflow: hidden;
        }
        
        .frame-thumb canvas {
            width: 100%;
            height: 100%;
            border: none;
            margin: 0;
        }
        
        .frame-thumb.active {
            border-color: #4a9eff;
            box-shadow: 0 0 8px rgba(74, 158, 255, 0.5);
        }
        
        .frame-thumb .frame-number {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 10px;
            padding: 1px 3px;
            border-radius: 2px;
        }
        
        .status-bar {
            background: #2a2a2a;
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #444;
            margin-top: 20px;
            font-size: 14px;
            color: #aaa;
        }
        
        .tools {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 10px 0;
        }
        
        .tool-btn {
            padding: 8px;
            font-size: 12px;
        }
        
        .tool-btn.active {
            background: #2ecc71;
            box-shadow: inset 0 0 0 2px rgba(255,255,255,0.2);
        }
        
        .info-text {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        .file-input-hidden {
            display: none;
        }
        
        .divider {
            height: 1px;
            background: #444;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="editor-section">
            <h1>Sprite & Tile Editor</h1>
            
            <div class="section">
                <h2>Editor Canvas</h2>
                <canvas id="mainCanvas" width="256" height="256"></canvas>
                
                <div class="control-group">
                    <button id="playBtn" class="success">‚ñ∂ Play Animation</button>
                    <button id="pauseBtn" class="secondary">‚è∏ Pause</button>
                    <button id="prevFrameBtn">‚óÄ Prev Frame</button>
                    <button id="nextFrameBtn">‚ñ∂ Next Frame</button>
                </div>
            </div>
            
            <div class="section">
                <h2>Frames</h2>
                <div class="frame-thumbnails" id="frameThumbnails"></div>
                <div class="control-group">
                    <button id="addFrameBtn">‚ûï Add Frame</button>
                    <button id="duplicateFrameBtn">‚éò Duplicate Frame</button>
                    <button id="deleteFrameBtn" class="danger">üóë Delete Frame</button>
                </div>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="section">
                <h2>Tools</h2>
                <div class="tools">
                    <button class="tool-btn active" data-tool="brush">üñå Brush</button>
                    <button class="tool-btn" data-tool="fill">üé® Fill</button>
                    <button class="tool-btn" data-tool="eyedropper">üíß Pick</button>
                    <button class="tool-btn" data-tool="eraser">üßΩ Eraser</button>
                    <button class="tool-btn" data-tool="rectangle">‚¨ú Rectangle</button>
                    <button class="tool-btn" data-tool="line">üìè Line</button>
                </div>
                
                <label for="brushSize">Brush Size:</label>
                <input type="range" id="brushSize" min="1" max="5" value="1">
                <div id="brushSizeDisplay">1√ó1</div>
            </div>
            
            <div class="section">
                <h2>Color Palette</h2>
                <div class="color-palette" id="colorPalette"></div>
                
                <div class="control-group">
                    <button id="addColorBtn">‚ûï Add Color</button>
                    <button id="deleteColorBtn" class="danger">üóë Delete Color</button>
                </div>
                
                <label for="colorInput">Custom Color (Hex):</label>
                <input type="color" id="colorPicker" value="#ff0000">
                <input type="text" id="colorInput" placeholder="#FF0000" value="#FF0000">
                
                <div class="info-text">Click color to select, click selected again to delete custom colors</div>
            </div>
            
            <div class="section">
                <h2>File Operations</h2>
                
                <label for="animationSpeed">Animation Speed (ms):</label>
                <input type="number" id="animationSpeed" min="50" max="2000" value="200">
                
                <div class="control-group">
                    <button id="importPNGBtn">üìÅ Import PNG</button>
                    <button id="exportPNGBtn">üíæ Export PNG</button>
                    <button id="exportJSONBtn">üìä Export JSON</button>
                </div>
                
                <input type="file" id="importFile" accept=".png" class="file-input-hidden">
            </div>
            
            <div class="status-bar">
                <div>Frame: <span id="frameIndex">0</span>/<span id="frameCount">1</span></div>
                <div>Tool: <span id="currentTool">Brush</span></div>
                <div>Color: <span id="currentColor">#000000</span></div>
                <div>Position: <span id="mousePos">X:0, Y:0</span></div>
            </div>
        </div>
    </div>

    <script>
        // === Constants ===
        const PIXEL_SIZE = 16;
        const CANVAS_SCALE = 16;
        const CANVAS_SIZE = PIXEL_SIZE * CANVAS_SCALE;
        const MAX_FRAMES = 20;
        const MAX_COLORS = 64;

        // === State Variables ===
        let frames = [];
        let currentFrame = 0;
        let currentColor = 0;
        let currentTool = 'brush';
        let brushSize = 1;
        let isDrawing = false;
        let isPlaying = false;
        let animationInterval = null;
        let lastMouseX = -1;
        let lastMouseY = -1;
        let startX = -1;
        let startY = -1;

        // Default palette (expanded with common colors)
        let palette = [
            '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF',
            '#FFFF00', '#FF00FF', '#00FFFF', '#FF8800', '#8800FF',
            '#0088FF', '#88FF00', '#FF0088', '#888888', '#444444',
            '#888800', '#008888', '#880088', '#AA5500', '#5500AA'
        ];

        // === Canvas Setup ===
        const mainCanvas = document.getElementById('mainCanvas');
        const ctx = mainCanvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // === Initialize ===
        function init() {
            // Create first frame
            frames.push(createEmptyFrame());
            
            // Initialize UI
            updateColorPalette();
            updateFrameThumbnails();
            updateUI();
            
            // Set up event listeners
            setupEventListeners();
            
            // Draw initial frame
            drawFrame();
        }

        // === Frame Management ===
        function createEmptyFrame() {
            const frame = [];
            for (let y = 0; y < PIXEL_SIZE; y++) {
                frame[y] = [];
                for (let x = 0; x < PIXEL_SIZE; x++) {
                    frame[y][x] = 0; // Transparent/background
                }
            }
            return frame;
        }

        function addFrame(copyCurrent = true) {
            if (frames.length >= MAX_FRAMES) {
                alert(`Maximum ${MAX_FRAMES} frames reached`);
                return;
            }
            
            let newFrame;
            if (copyCurrent && frames.length > 0) {
                // Deep copy current frame
                newFrame = JSON.parse(JSON.stringify(frames[currentFrame]));
            } else {
                newFrame = createEmptyFrame();
            }
            
            frames.push(newFrame);
            currentFrame = frames.length - 1;
            updateFrameThumbnails();
            drawFrame();
        }

        function deleteFrame() {
            if (frames.length <= 1) {
                alert("Cannot delete the last frame");
                return;
            }
            
            frames.splice(currentFrame, 1);
            currentFrame = Math.min(currentFrame, frames.length - 1);
            updateFrameThumbnails();
            drawFrame();
        }

        function duplicateFrame() {
            addFrame(true);
        }

        // === Drawing Functions ===
        function drawPixel(x, y, colorIndex = currentColor) {
            if (x < 0 || x >= PIXEL_SIZE || y < 0 || y >= PIXEL_SIZE) return;
            
            const frame = frames[currentFrame];
            
            if (brushSize === 1) {
                frame[y][x] = colorIndex;
            } else {
                // Draw with brush size
                const radius = Math.floor(brushSize / 2);
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const px = x + dx;
                        const py = y + dy;
                        if (px >= 0 && px < PIXEL_SIZE && py >= 0 && py < PIXEL_SIZE) {
                            frame[py][px] = colorIndex;
                        }
                    }
                }
            }
            
            drawFrame();
        }

        function fillArea(x, y, targetColor, fillColor) {
            if (x < 0 || x >= PIXEL_SIZE || y < 0 || y >= PIXEL_SIZE) return;
            
            const frame = frames[currentFrame];
            if (frame[y][x] !== targetColor || targetColor === fillColor) return;
            
            const stack = [[x, y]];
            
            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                if (cx < 0 || cx >= PIXEL_SIZE || cy < 0 || cy >= PIXEL_SIZE) continue;
                if (frame[cy][cx] !== targetColor) continue;
                
                frame[cy][cx] = fillColor;
                
                stack.push([cx + 1, cy]);
                stack.push([cx - 1, cy]);
                stack.push([cx, cy + 1]);
                stack.push([cx, cy - 1]);
            }
            
            drawFrame();
        }

        function drawRectangle(x1, y1, x2, y2, colorIndex) {
            const startX = Math.max(0, Math.min(x1, x2));
            const endX = Math.min(PIXEL_SIZE - 1, Math.max(x1, x2));
            const startY = Math.max(0, Math.min(y1, y2));
            const endY = Math.min(PIXEL_SIZE - 1, Math.max(y1, y2));
            
            const frame = frames[currentFrame];
            for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                    frame[y][x] = colorIndex;
                }
            }
            
            drawFrame();
        }

        function drawLine(x1, y1, x2, y2, colorIndex) {
            const frame = frames[currentFrame];
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                if (x1 >= 0 && x1 < PIXEL_SIZE && y1 >= 0 && y1 < PIXEL_SIZE) {
                    frame[y1][x1] = colorIndex;
                }
                
                if (x1 === x2 && y1 === y2) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x1 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y1 += sy;
                }
            }
            
            drawFrame();
        }

        // === Rendering ===
        function drawFrame() {
            // Clear canvas
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Draw grid
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= PIXEL_SIZE; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CANVAS_SCALE, 0);
                ctx.lineTo(x * CANVAS_SCALE, CANVAS_SIZE);
                ctx.stroke();
            }
            
            for (let y = 0; y <= PIXEL_SIZE; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CANVAS_SCALE);
                ctx.lineTo(CANVAS_SIZE, y * CANVAS_SCALE);
                ctx.stroke();
            }
            
            // Draw pixels
            const frame = frames[currentFrame];
            for (let y = 0; y < PIXEL_SIZE; y++) {
                for (let x = 0; x < PIXEL_SIZE; x++) {
                    const colorIndex = frame[y][x];
                    if (colorIndex > 0) { // 0 is transparent/background
                        ctx.fillStyle = palette[colorIndex];
                        ctx.fillRect(
                            x * CANVAS_SCALE + 1,
                            y * CANVAS_SCALE + 1,
                            CANVAS_SCALE - 2,
                            CANVAS_SCALE - 2
                        );
                    }
                }
            }
            
            // Update UI
            updateUI();
        }

        function drawFrameThumbnail(frameIndex, canvas) {
            const ctx = canvas.getContext('2d');
            const frame = frames[frameIndex];
            const scale = canvas.width / PIXEL_SIZE;
            
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < PIXEL_SIZE; y++) {
                for (let x = 0; x < PIXEL_SIZE; x++) {
                    const colorIndex = frame[y][x];
                    if (colorIndex > 0) {
                        ctx.fillStyle = palette[colorIndex];
                        ctx.fillRect(x * scale, y * scale, scale, scale);
                    }
                }
            }
        }

        // === Animation ===
        function playAnimation() {
            if (isPlaying || frames.length < 2) return;
            
            isPlaying = true;
            const speed = parseInt(document.getElementById('animationSpeed').value) || 200;
            
            animationInterval = setInterval(() => {
                currentFrame = (currentFrame + 1) % frames.length;
                drawFrame();
                updateFrameThumbnails();
            }, speed);
        }

        function pauseAnimation() {
            isPlaying = false;
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        // === Color Palette ===
        function updateColorPalette() {
            const container = document.getElementById('colorPalette');
            container.innerHTML = '';
            
            palette.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                
                if (index === currentColor) {
                    swatch.classList.add('selected');
                }
                
                const indexLabel = document.createElement('div');
                indexLabel.className = 'color-index';
                indexLabel.textContent = index;
                
                swatch.appendChild(indexLabel);
                
                swatch.addEventListener('click', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        // Ctrl+Click to delete custom color (index >= 20)
                        if (index >= 20) {
                            deleteColor(index);
                        }
                    } else {
                        selectColor(index);
                    }
                });
                
                container.appendChild(swatch);
            });
        }

        function selectColor(index) {
            currentColor = index;
            updateColorPalette();
            updateUI();
        }

        function addColor(hexColor) {
            if (palette.length >= MAX_COLORS) {
                alert(`Maximum ${MAX_COLORS} colors reached`);
                return;
            }
            
            // Validate hex color
            if (!/^#[0-9A-F]{6}$/i.test(hexColor)) {
                alert('Please enter a valid hex color (e.g., #FF0000)');
                return;
            }
            
            hexColor = hexColor.toUpperCase();
            
            // Check if color already exists
            if (palette.includes(hexColor)) {
                alert('This color is already in the palette!');
                selectColor(palette.indexOf(hexColor));
                return;
            }
            
            palette.push(hexColor);
            currentColor = palette.length - 1;
            updateColorPalette();
            updateUI();
        }

        function deleteColor(index) {
            if (index < 20) {
                alert('Cannot delete default colors (0-19)');
                return;
            }
            
            if (palette.length <= 20) {
                alert('Must keep at least 20 colors');
                return;
            }
            
            // Remove color from palette
            palette.splice(index, 1);
            
            // Update all frames to use index 0 for deleted color
            for (let f = 0; f < frames.length; f++) {
                for (let y = 0; y < PIXEL_SIZE; y++) {
                    for (let x = 0; x < PIXEL_SIZE; x++) {
                        if (frames[f][y][x] === index) {
                            frames[f][y][x] = 0;
                        } else if (frames[f][y][x] > index) {
                            frames[f][y][x]--;
                        }
                    }
                }
            }
            
            // Adjust current color if needed
            if (currentColor === index) {
                currentColor = 0;
            } else if (currentColor > index) {
                currentColor--;
            }
            
            updateColorPalette();
            drawFrame();
        }

        // === File Operations ===
        async function importPNG(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // Check image dimensions
                        if (img.width !== PIXEL_SIZE || img.height !== PIXEL_SIZE) {
                            alert(`Image must be ${PIXEL_SIZE}√ó${PIXEL_SIZE} pixels`);
                            reject(new Error('Invalid dimensions'));
                            return;
                        }
                        
                        // Create temporary canvas to read pixel data
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = PIXEL_SIZE;
                        tempCanvas.height = PIXEL_SIZE;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0);
                        
                        const imageData = tempCtx.getImageData(0, 0, PIXEL_SIZE, PIXEL_SIZE);
                        const data = imageData.data;
                        
                        // Extract colors and create new frame
                        const newFrame = createEmptyFrame();
                        const foundColors = new Set();
                        
                        for (let y = 0; y < PIXEL_SIZE; y++) {
                            for (let x = 0; x < PIXEL_SIZE; x++) {
                                const idx = (y * PIXEL_SIZE + x) * 4;
                                const r = data[idx];
                                const g = data[idx + 1];
                                const b = data[idx + 2];
                                const a = data[idx + 3];
                                
                                if (a === 0) {
                                    // Transparent pixel
                                    newFrame[y][x] = 0;
                                } else {
                                    const hex = rgbToHex(r, g, b);
                                    foundColors.add(hex);
                                    
                                    // Find or add color to palette
                                    let colorIndex = palette.indexOf(hex);
                                    if (colorIndex === -1) {
                                        if (palette.length < MAX_COLORS) {
                                            palette.push(hex);
                                            colorIndex = palette.length - 1;
                                        } else {
                                            // Fallback: find closest color
                                            colorIndex = findClosestColor(hex);
                                        }
                                    }
                                    
                                    newFrame[y][x] = colorIndex;
                                }
                            }
                        }
                        
                        // Add new frame
                        frames.push(newFrame);
                        currentFrame = frames.length - 1;
                        
                        // Update UI
                        updateColorPalette();
                        updateFrameThumbnails();
                        drawFrame();
                        
                        alert(`PNG imported successfully! Found ${foundColors.size} unique colors.`);
                        resolve();
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function exportPNG() {
            const frame = frames[currentFrame];
            const canvas = document.createElement('canvas');
            canvas.width = PIXEL_SIZE;
            canvas.height = PIXEL_SIZE;
            const ctx = canvas.getContext('2d');
            
            // Fill with transparency
            ctx.clearRect(0, 0, PIXEL_SIZE, PIXEL_SIZE);
            
            // Draw pixels
            for (let y = 0; y < PIXEL_SIZE; y++) {
                for (let x = 0; x < PIXEL_SIZE; x++) {
                    const colorIndex = frame[y][x];
                    if (colorIndex > 0) {
                        ctx.fillStyle = palette[colorIndex];
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
            
            // Create download link
            const link = document.createElement('a');
            link.download = `sprite_frame_${currentFrame}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function exportJSON() {
            const data = {
                palette: palette,
                frames: frames,
                size: PIXEL_SIZE,
                version: '1.0',
                exported: new Date().toISOString()
            };
            
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `sprite_${Date.now()}.json`;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        // === Utility Functions ===
        function rgbToHex(r, g, b) {
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function findClosestColor(hex) {
            const targetRgb = hexToRgb(hex);
            if (!targetRgb) return 0;
            
            let closestIndex = 0;
            let minDistance = Infinity;
            
            for (let i = 0; i < palette.length; i++) {
                const rgb = hexToRgb(palette[i]);
                if (rgb) {
                    const distance = Math.sqrt(
                        Math.pow(targetRgb.r - rgb.r, 2) +
                        Math.pow(targetRgb.g - rgb.g, 2) +
                        Math.pow(targetRgb.b - rgb.b, 2)
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
            }
            
            return closestIndex;
        }

        // === UI Updates ===
        function updateFrameThumbnails() {
            const container = document.getElementById('frameThumbnails');
            container.innerHTML = '';
            
            frames.forEach((frame, index) => {
                const thumb = document.createElement('div');
                thumb.className = `frame-thumb ${index === currentFrame ? 'active' : ''}`;
                thumb.title = `Frame ${index}`;
                
                const canvas = document.createElement('canvas');
                canvas.width = 40;
                canvas.height = 40;
                
                const number = document.createElement('div');
                number.className = 'frame-number';
                number.textContent = index;
                
                thumb.appendChild(canvas);
                thumb.appendChild(number);
                
                thumb.addEventListener('click', () => {
                    if (!isPlaying) {
                        currentFrame = index;
                        drawFrame();
                        updateFrameThumbnails();
                    }
                });
                
                container.appendChild(thumb);
                drawFrameThumbnail(index, canvas);
            });
        }

        function updateUI() {
            // Update status displays
            document.getElementById('frameIndex').textContent = currentFrame;
            document.getElementById('frameCount').textContent = frames.length - 1;
            document.getElementById('currentTool').textContent = currentTool.charAt(0).toUpperCase() + currentTool.slice(1);
            document.getElementById('currentColor').textContent = palette[currentColor];
            document.getElementById('brushSizeDisplay').textContent = `${brushSize}√ó${brushSize}`;
            
            // Update tool buttons
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === currentTool);
            });
        }

        // === Event Handlers ===
        function setupEventListeners() {
            // Canvas events
            mainCanvas.addEventListener('mousedown', handleMouseDown);
            mainCanvas.addEventListener('mousemove', handleMouseMove);
            mainCanvas.addEventListener('mouseup', handleMouseUp);
            mainCanvas.addEventListener('mouseleave', handleMouseLeave);
            
            // Tool selection
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentTool = btn.dataset.tool;
                    updateUI();
                });
            });
            
            // Brush size
            document.getElementById('brushSize').addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                updateUI();
            });
            
            // Frame controls
            document.getElementById('addFrameBtn').addEventListener('click', () => addFrame(false));
            document.getElementById('duplicateFrameBtn').addEventListener('click', duplicateFrame);
            document.getElementById('deleteFrameBtn').addEventListener('click', deleteFrame);
            document.getElementById('prevFrameBtn').addEventListener('click', () => {
                if (!isPlaying && frames.length > 1) {
                    currentFrame = (currentFrame - 1 + frames.length) % frames.length;
                    drawFrame();
                    updateFrameThumbnails();
                }
            });
            document.getElementById('nextFrameBtn').addEventListener('click', () => {
                if (!isPlaying && frames.length > 1) {
                    currentFrame = (currentFrame + 1) % frames.length;
                    drawFrame();
                    updateFrameThumbnails();
                }
            });
            
            // Animation controls
            document.getElementById('playBtn').addEventListener('click', playAnimation);
            document.getElementById('pauseBtn').addEventListener('click', pauseAnimation);
            
            // Color controls
            document.getElementById('addColorBtn').addEventListener('click', () => {
                const color = document.getElementById('colorInput').value;
                addColor(color);
            });
            
            document.getElementById('deleteColorBtn').addEventListener('click', () => {
                deleteColor(currentColor);
            });
            
            document.getElementById('colorPicker').addEventListener('input', (e) => {
                document.getElementById('colorInput').value = e.target.value;
            });
            
            document.getElementById('colorInput').addEventListener('change', (e) => {
                document.getElementById('colorPicker').value = e.target.value;
            });
            
            // File operations
            document.getElementById('importPNGBtn').addEventListener('click', () => {
                document.getElementById('importFile').click();
            });
            
            document.getElementById('importFile').addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    importPNG(e.target.files[0]).catch(console.error);
                }
            });
            
            document.getElementById('exportPNGBtn').addEventListener('click', exportPNG);
            document.getElementById('exportJSONBtn').addEventListener('click', exportJSON);
        }

        function handleMouseDown(e) {
            if (isPlaying) return;
            
            const rect = mainCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CANVAS_SCALE);
            const y = Math.floor((e.clientY - rect.top) / CANVAS_SCALE);
            
            if (x < 0 || x >= PIXEL_SIZE || y < 0 || y >= PIXEL_SIZE) return;
            
            isDrawing = true;
            startX = x;
            startY = y;
            lastMouseX = x;
            lastMouseY = y;
            
            switch (currentTool) {
                case 'brush':
                case 'eraser':
                    const color = currentTool === 'eraser' ? 0 : currentColor;
                    drawPixel(x, y, color);
                    break;
                    
                case 'eyedropper':
                    const frame = frames[currentFrame];
                    selectColor(frame[y][x]);
                    break;
                    
                case 'fill':
                    const targetColor = frames[currentFrame][y][x];
                    fillArea(x, y, targetColor, currentColor);
                    break;
            }
        }

        function handleMouseMove(e) {
            const rect = mainCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CANVAS_SCALE);
            const y = Math.floor((e.clientY - rect.top) / CANVAS_SCALE);
            
            // Update mouse position display
            document.getElementById('mousePos').textContent = `X:${x}, Y:${y}`;
            
            if (!isDrawing) return;
            
            if (x === lastMouseX && y === lastMouseY) return;
            
            lastMouseX = x;
            lastMouseY = y;
            
            switch (currentTool) {
                case 'brush':
                case 'eraser':
                    const color = currentTool === 'eraser' ? 0 : currentColor;
                    drawPixel(x, y, color);
                    break;
                    
                case 'line':
                    // Preview line (draw temporary line)
                    break;
                    
                case 'rectangle':
                    // Preview rectangle (draw temporary rectangle)
                    break;
            }
        }

        function handleMouseUp(e) {
            if (!isDrawing) return;
            
            const rect = mainCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CANVAS_SCALE);
            const y = Math.floor((e.clientY - rect.top) / CANVAS_SCALE);
            
            switch (currentTool) {
                case 'line':
                    drawLine(startX, startY, x, y, currentColor);
                    break;
                    
                case 'rectangle':
                    drawRectangle(startX, startY, x, y, currentColor);
                    break;
            }
            
            isDrawing = false;
            startX = -1;
            startY = -1;
        }

        function handleMouseLeave() {
            isDrawing = false;
            startX = -1;
            startY = -1;
            document.getElementById('mousePos').textContent = 'X:0, Y:0';
        }

        // === Initialize App ===
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>